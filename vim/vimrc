let mapleader = "\<Space>"

" Vundle set up
set nocompatible " be iMproved, required
filetype off " required

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

" let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'
Plugin 'tpope/vim-surround'
Plugin 'tpope/vim-repeat'
Plugin 'tpope/vim-rails'
Plugin 'tpope/vim-commentary'
Plugin 'tpope/vim-dispatch'
Plugin 'tpope/vim-fugitive'
Plugin 'thoughtbot/vim-rspec'
Plugin 'jiangmiao/auto-pairs'
let g:AutoPairsShortcutFastWrap = '<C-w>'
let g:AutoPairsShortcutBackInsert = '<C-b>'
let g:AutoPairsFlyMode = 0

Plugin 'Yggdroot/indentLine'
Plugin 'ervandew/supertab'
Plugin 'vim-scripts/ReplaceWithRegister'
Plugin 'vim-scripts/BufOnly.vim'
Plugin 'rking/ag.vim'
Plugin 'Chun-Yang/vim-action-ag'
Plugin 'kana/vim-textobj-user'
Plugin 'kana/vim-textobj-indent'
Plugin 'kana/vim-textobj-line'
Plugin 'kana/vim-textobj-entire'
Plugin 'nelstrom/vim-textobj-rubyblock'
Plugin 'tpope/vim-unimpaired'
Plugin 'sheerun/vim-polyglot'
Plugin 'itchyny/lightline.vim'

let g:rspec_command = "Dispatch rspec -I . --color -f p {spec}"

" CtrlP is a fuzzy file finder that allows you to very rapidly find a file without needing to type out (or even know) the full path to the file.
Plugin 'ctrlpvim/ctrlp.vim'

" Make CtrlP use ag for listing the files. Way faster and no useless files.
let g:ctrlp_user_command = 'ag %s -l --hidden --nocolor -g ""'
let g:ctrlp_use_caching = 0

Plugin 'altercation/vim-colors-solarized'
Plugin 'joshdick/onedark.vim'
Plugin 'vim-ruby/vim-ruby'

Plugin '907th/vim-auto-save'
let g:auto_save = 1

Plugin 'slim-template/vim-slim.git'
Plugin 'kchmck/vim-coffee-script'

" Plugin 'vim-airline/vim-airline'
" Plugin 'vim-airline/vim-airline-themes'

" let g:airline_powerline_fonts = 1

" if !exists('g:airline_symbols')
"   let g:airline_symbols = {}
" endif

" let g:airline_left_sep = '‚ñ∂'
" let g:airline_right_sep = '‚óÄ'
" let g:airline_symbols.crypt = 'üîí'
" let g:airline_symbols.linenr = '‚êä'
" let g:airline_symbols.maxlinenr = '‚ò∞'
" let g:airline_symbols.branch = '‚éá'
" let g:airline_symbols.paste = 'œÅ'
" let g:airline_symbols.spell = 'Íû®'
" let g:airline_symbols.notexists = '‚àÑ'
" let g:airline_symbols.whitespace = 'Œû'

Plugin 'scrooloose/nerdtree'
let g:NERDTreeShowHidden = 1
let g:NERDTreeMinimalUI = 1
let g:NERDTreeAutoDeleteBuffer = 1
let NERDTreeIgnore=['.git$', 'node_modules', '\.swp$', '\.DS_Store$']

Plugin 'jeffkreeftmeijer/vim-numbertoggle'
Plugin 'djoshea/vim-autoread'
Plugin 'sandeepcr529/Buffet.vim'
Plugin 'skwp/greplace.vim'
Plugin 'dracula/vim'

Plugin 'majutsushi/tagbar'
" Leader m to trigger

Plugin 'mattn/emmet-vim'
" <C-Y>, to trigger

" JS plugins for VIM
Plugin 'mxw/vim-jsx'
let g:jsx_ext_required = 0
Plugin 'pangloss/vim-javascript'
Plugin 'elzr/vim-json'
let g:indentLine_noConcealCursor="" " Needed because of Yggdroot/indentLine
Plugin 'scrooloose/syntastic'
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_loc_list_height = 5
let g:syntastic_auto_loc_list = 0
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 1
let g:syntastic_javascript_checkers = ['eslint']
let g:syntastic_javascript_eslint_exec = 'eslint_d' " Faster syntax checking
let g:syntastic_json_checkers=['jsonlint']
let g:syntastic_error_symbol = '‚ùå'
let g:syntastic_style_error_symbol = '‚ÅâÔ∏è'
let g:syntastic_warning_symbol = '‚ö†Ô∏è'
let g:syntastic_style_warning_symbol = 'üí©'
highlight link SyntasticErrorSign SignColumn
highlight link SyntasticWarningSign SignColumn
highlight link SyntasticStyleErrorSign SignColumn
highlight link SyntasticStyleWarningSign SignColumn
" npm install -g eslint eslint-config-standard eslint-plugin-import eslint-plugin-promise eslint-plugin-react eslint-plugin-standard

" All of your Plugins must be added before the following line
call vundle#end()            " required
filetype plugin indent on    " required

" if !has('gui_running')
"   set t_Co=256
" endif

if (has("autocmd") && !has("gui"))
  let s:white = { "gui": "#ABB2BF", "cterm": "145", "cterm16" : "7" }
  autocmd ColorScheme * call onedark#set_highlight("Normal", { "fg": s:white }) " No `bg` setting
end

if has('nvim')
  nmap <BS> <C-W>h
endif

let g:onedark_termcolors=16

syntax on
colorscheme onedark
" set background=dark
" color dracula

" Map 0 to move cursor to first character of line
nmap 0 ^

" Edit Vim
nmap <leader>ve :vsplit $MYVIMRC<cr>

" Open cheatsheet
nmap <leader>cs :vsplit ~/workspace/dotfiles/vim/cheatsheet.md<cr>

" Opens NerdTree
nmap <leader>n :NERDTreeToggle<CR>

" Navigation around windows
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>

runtime macros/matchit.vim

set encoding=utf-8
scriptencoding utf-8
set mouse=a
set number
set wildmenu
set wildmode=full
set switchbuf=useopen,usetab
set history=500
set splitbelow
set splitright
set numberwidth=4
set nowrap
set showcmd
set backspace=indent,eol,start
set tabstop=2
set shiftwidth=2
set expandtab
set hlsearch
set incsearch
set ignorecase
set cursorline
set autoindent
set laststatus=2
set formatoptions-=or " Don't add the comment prefix when I hit enter or o/O on a comment line."

" Lower timeout for mappings (faster response)
set ttimeout
set timeout timeoutlen=300 ttimeoutlen=300

set noswapfile " No stupid .swp file
set clipboard=unnamed " Yanks text into system clipboard
set pastetoggle=<leader>p " Toggle paste and nopaste mode

" Make VIM run fast even in large long lines files
set synmaxcol=300

nmap <Leader>/ :nohlsearch<CR>

" RSpec.vim mappings

map <Leader>t :call RunCurrentSpecFile()<CR>
map <Leader>s :call RunNearestSpec()<CR>
map <Leader>l :call RunLastSpec()<CR>
map <Leader>a :call RunAllSpecs()<CR>

" Code format entire file
map <Leader>= ggVG=

inoremap jk <C-o>a
inoremap kj <C-o>A

" Open buffet list
map <Leader>b :Bufferlist<cr>

" Opens Tagbar
map <Leader>m :TagbarToggle<CR>

" Quickfix windows open and close
map <Leader>qq :cclose<CR>
map <Leader>qf :copen<CR>

" Split lines above
map <Leader>K i<cr><esc><up>:m +1<cr>

" Split lines below
map <Leader>k i<cr><esc>"

" Delete all buffers but leave the current
map <Leader>x :BufOnly<cr>

" Close the next window
map <Leader>X <c-w><c-w>:q<CR>

" Reloads $MYVIMRC
map <Leader>r :so $MYVIMRC<cr>

" Insert a line break above
nmap K 0i<cr><esc>

" Navigate around methods
nmap gm ]m
nmap gn [m

" Auto-expand %% to the current file directory
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%']"

" Wild ignore all node modules
set wildignore+=node_modules

" Faster redraws in terminal Vim ?
set lazyredraw
set ttyfast

" find . -type f -iregex ".*\.js$" -not -path "./node_modules/*" -exec jsctags {} -f \; | sed '/^$/d' | sort > tags

let g:lightline = {
      \ 'colorscheme': 'onedark',
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ], ['ctrlpmark'] ],
      \   'right': [ [ 'syntastic', 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
      \ },
      \ 'component_function': {
      \   'fugitive': 'LightlineFugitive',
      \   'filename': 'LightlineFilename',
      \   'fileformat': 'LightlineFileformat',
      \   'filetype': 'LightlineFiletype',
      \   'fileencoding': 'LightlineFileencoding',
      \   'mode': 'LightlineMode',
      \   'ctrlpmark': 'CtrlPMark',
      \ },
      \ 'component_expand': {
      \   'syntastic': 'SyntasticStatuslineFlag',
      \ },
      \ 'component_type': {
      \   'syntastic': 'error',
      \ },
      \ 'separator': { 'left': "\ue0b0", 'right': "\ue0b2" },
      \ 'subseparator': { 'left': "\ue0b1", 'right': "\ue0b3" }
      \ }

function! LightlineModified()
  return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! LightlineReadonly()
  return &ft !~? 'help' && &readonly ? "\ue0a2" : ''
endfunction

function! LightlineFilename()
  let fname = expand('%:t')
  return fname == 'ControlP' && has_key(g:lightline, 'ctrlp_item') ? g:lightline.ctrlp_item :
        \ fname == '__Tagbar__' ? g:lightline.fname :
        \ fname =~ '__Gundo\|NERD_tree' ? '' :
        \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
        \ &ft == 'unite' ? unite#get_status_string() :
        \ &ft == 'vimshell' ? vimshell#get_status_string() :
        \ ('' != LightlineReadonly() ? LightlineReadonly() . ' ' : '') .
        \ ('' != fname ? fname : '[No Name]') .
        \ ('' != LightlineModified() ? ' ' . LightlineModified() : '')
endfunction

function! LightlineFugitive()
  try
    if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
      let mark = "\ue0a0"  " edit here for cool mark
      let branch = fugitive#head()
      return branch !=# '' ? mark.branch : ''
    endif
  catch
  endtry
  return ''
endfunction

function! LightlineFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! LightlineFiletype()
  return winwidth(0) > 70 ? (&filetype !=# '' ? &filetype : 'no ft') : ''
endfunction

function! LightlineFileencoding()
  return winwidth(0) > 70 ? (&fenc !=# '' ? &fenc : &enc) : ''
endfunction

function! LightlineMode()
  let fname = expand('%:t')
  return fname == '__Tagbar__' ? 'Tagbar' :
        \ fname == 'ControlP' ? 'CtrlP' :
        \ fname == '__Gundo__' ? 'Gundo' :
        \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
        \ fname =~ 'NERD_tree' ? 'NERDTree' :
        \ &ft == 'unite' ? 'Unite' :
        \ &ft == 'vimfiler' ? 'VimFiler' :
        \ &ft == 'vimshell' ? 'VimShell' :
        \ winwidth(0) > 60 ? lightline#mode() : ''
endfunction

function! CtrlPMark()
  if expand('%:t') =~ 'ControlP' && has_key(g:lightline, 'ctrlp_item')
    call lightline#link('iR'[g:lightline.ctrlp_regex])
    return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
          \ , g:lightline.ctrlp_next], 0)
  else
    return ''
  endif
endfunction

let g:ctrlp_status_func = {
  \ 'main': 'CtrlPStatusFunc_1',
  \ 'prog': 'CtrlPStatusFunc_2',
  \ }

function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
  let g:lightline.ctrlp_regex = a:regex
  let g:lightline.ctrlp_prev = a:prev
  let g:lightline.ctrlp_item = a:item
  let g:lightline.ctrlp_next = a:next
  return lightline#statusline(0)
endfunction

function! CtrlPStatusFunc_2(str)
  return lightline#statusline(0)
endfunction

let g:tagbar_status_func = 'TagbarStatusFunc'

function! TagbarStatusFunc(current, sort, fname, ...) abort
    let g:lightline.fname = a:fname
  return lightline#statusline(0)
endfunction

augroup AutoSyntastic
  autocmd!
  autocmd BufWritePost *.c,*.cpp call s:syntastic()
augroup END
function! s:syntastic()
  SyntasticCheck
  call lightline#update()
endfunction

let g:unite_force_overwrite_statusline = 0
let g:vimfiler_force_overwrite_statusline = 0
let g:vimshell_force_overwrite_statusline = 0
